{
    "id": "CVE-2025-22036",
    "product": "Linux",
    "version": "11a347fb6cef62ce47e84b97c45f2b2497c7593b< 49b0a6ab8e528a0c1c50e37cef9b9c7c121365f2 ",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:exfat: fix random stack corruption after get_blockWhen get_block is called with a buffer_head allocated on the stack, suchas do_mpage_readpage, stack corruption due to buffer_head UAF may occur inthe following race condition situation.     <CPU 0>                      <CPU 1>mpage_read_folio  <<bh on stack>>  do_mpage_readpage    exfat_get_block      bh_read        __bh_read\t  get_bh(bh)          submit_bh          wait_on_buffer                              ...                              end_buffer_read_sync                                __end_buffer_read_notouch                                   unlock_buffer          <<keep going>>        ...      ...    ...  ...<<bh is not valid out of mpage_read_folio>>   .   .another_function  <<variable A on stack>>                                   put_bh(bh)                                     atomic_dec(bh->b_count)  * stack corruption here *This patch returns -EAGAIN if a folio does not have buffers when bh_readneeds to be called. By doing this, the caller can fallback to functionslike block_read_full_folio(), create a buffer_head in the folio, and thencall get_block again.Let's do not call bh_read() with on-stack buffer_head.",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/ARPSyndicate/cve-scores"
        ]
    }
}