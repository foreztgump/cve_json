{
    "id": "CVE-2025-38527",
    "product": "Linux",
    "version": "",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:smb: client: fix use-after-free in cifs_oplock_breakA race condition can occur in cifs_oplock_break() leading to ause-after-free of the cinode structure when unmounting:  cifs_oplock_break()    _cifsFileInfo_put(cfile)      cifsFileInfo_put_final()        cifs_sb_deactive()          [last ref, start releasing sb]            kill_sb()              kill_anon_super()                generic_shutdown_super()                  evict_inodes()                    dispose_list()                      evict()                        destroy_inode()                          call_rcu(&inode->i_rcu, i_callback)    spin_lock(&cinode->open_file_lock)  <- OK                            [later] i_callback()                              cifs_free_inode()                                kmem_cache_free(cinode)    spin_unlock(&cinode->open_file_lock)  <- UAF    cifs_done_oplock_break(cinode)       <- UAFThe issue occurs when umount has already released its reference to thesuperblock. When _cifsFileInfo_put() calls cifs_sb_deactive(), thisreleases the last reference, triggering the immediate cleanup of allinodes under RCU. However, cifs_oplock_break() continues to access thecinode after this point, resulting in use-after-free.Fix this by holding an extra reference to the superblock during theentire oplock break operation. This ensures that the superblock andits inodes remain valid until the oplock break completes.",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/w4zu/Debian_security"
        ]
    }
}