{
    "id": "CVE-2025-37953",
    "product": "Linux",
    "version": "73cf6af13153d62f9b76eff422eea79dbc70f15e< c928dd4f6bf0c25c72b11824a1e9ac9bd37296a0 ",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:sch_htb: make htb_deactivate() idempotentAlan reported a NULL pointer dereference in htb_next_rb_node()after we made htb_qlen_notify() idempotent.It turns out in the following case it introduced some regression:htb_dequeue_tree():  |-> fq_codel_dequeue()    |-> qdisc_tree_reduce_backlog()      |-> htb_qlen_notify()        |-> htb_deactivate()  |-> htb_next_rb_node()  |-> htb_deactivate()For htb_next_rb_node(), after calling the 1st htb_deactivate(), theclprio[prio]->ptr could be already set to  NULL, which meanshtb_next_rb_node() is vulnerable here.For htb_deactivate(), although we checked qlen before calling it, incase of qlen==0 after qdisc_tree_reduce_backlog(), we may call it againwhich triggers the warning inside.To fix the issues here, we need to:1) Make htb_deactivate() idempotent, that is, simply return if we   already call it before.2) Make htb_next_rb_node() safe against ptr==NULL.Many thanks to Alan for testing and for the reproducer.",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/runwhen-contrib/helm-charts"
        ]
    }
}