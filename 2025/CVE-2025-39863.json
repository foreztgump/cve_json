{
    "id": "CVE-2025-39863",
    "product": "Linux",
    "version": "",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:wifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info workThe brcmf_btcoex_detach() only shuts down the btcoex timer, if theflag timer_on is false. However, the brcmf_btcoex_timerfunc(), whichruns as timer handler, sets timer_on to false. This creates criticalrace conditions:1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()is executing, it may observe timer_on as false and skip the call totimer_shutdown_sync().2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_infoworker after the cancel_work_sync() has been executed, resulting inuse-after-free bugs.The use-after-free bugs occur in two distinct scenarios, depending onthe timing of when the brcmf_btcoex_info struct is freed relative tothe execution of its worker thread.Scenario 1: Freed before the worker is scheduledThe brcmf_btcoex_info is deallocated before the worker is scheduled.A race condition can occur when schedule_work(&bt_local->work) iscalled after the target memory has been freed. The sequence of eventsis detailed below:CPU0                           | CPU1brcmf_btcoex_detach            | brcmf_btcoex_timerfunc                               |   bt_local->timer_on = false;  if (cfg->btcoex->timer_on)   |    ...                        |  cancel_work_sync();          |  ...                          |  kfree(cfg->btcoex); // FREE  |                               |   schedule_work(&bt_local->work); // USEScenario 2: Freed after the worker is scheduledThe brcmf_btcoex_info is freed after the worker has been scheduledbut before or during its execution. In this case, statements withinthe brcmf_btcoex_handler() \u00e2\u20ac\u201d such as the container_of macro andsubsequent dereferences of the brcmf_btcoex_info object will causea use-after-free access. The following timeline illustrates thisscenario:CPU0                            | CPU1brcmf_btcoex_detach             | brcmf_btcoex_timerfunc                                |   bt_local->timer_on = false;  if (cfg->btcoex->timer_on)    |    ...                         |  cancel_work_sync();           |  ...                           |   schedule_work(); // Reschedule                                |  kfree(cfg->btcoex); // FREE   |   brcmf_btcoex_handler() // Worker  /*                            |     btci = container_of(....); // USE   The kfree() above could      |     ...   also occur at any point      |     btci-> // USE   during the worker's execution|   */                           |To resolve the race conditions, drop the conditional check and calltimer_shutdown_sync() directly. It can deactivate the timer reliably,regardless of its current state. Once stopped, the timer_on state isthen set to false.",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/w4zu/Debian_security"
        ]
    }
}