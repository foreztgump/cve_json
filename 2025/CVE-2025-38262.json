{
    "id": "CVE-2025-38262",
    "product": "Linux",
    "version": "",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:tty: serial: uartlite: register uart driver in initWhen two instances of uart devices are probing, a concurrency race canoccur. If one thread calls uart_register_driver function, which firstallocates and assigns memory to 'uart_state' member of uart_driverstructure, the other instance can bypass uart driver registration andcall ulite_assign. This calls uart_add_one_port, which expects the uartdriver to be fully initialized. This leads to a kernel panic due to anull pointer dereference:[    8.143581] BUG: kernel NULL pointer dereference, address: 00000000000002b8[    8.156982] #PF: supervisor write access in kernel mode[    8.156984] #PF: error_code(0x0002) - not-present page[    8.156986] PGD 0 P4D 0...[    8.180668] RIP: 0010:mutex_lock+0x19/0x30[    8.188624] Call Trace:[    8.188629]  ? __die_body.cold+0x1a/0x1f[    8.195260]  ? page_fault_oops+0x15c/0x290[    8.209183]  ? __irq_resolve_mapping+0x47/0x80[    8.209187]  ? exc_page_fault+0x64/0x140[    8.209190]  ? asm_exc_page_fault+0x22/0x30[    8.209196]  ? mutex_lock+0x19/0x30[    8.223116]  uart_add_one_port+0x60/0x440[    8.223122]  ? proc_tty_register_driver+0x43/0x50[    8.223126]  ? tty_register_driver+0x1ca/0x1e0[    8.246250]  ulite_probe+0x357/0x4b0 [uartlite]To prevent it, move uart driver registration in to init function. Thiswill ensure that uart_driver is always registered when probe functionis called.",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/w4zu/Debian_security"
        ]
    }
}