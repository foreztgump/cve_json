{
    "id": "CVE-2025-39691",
    "product": "Linux",
    "version": "",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:fs/buffer: fix use-after-free when call bh_read() helperThere's issue as follows:BUG: KASAN: stack-out-of-bounds in end_buffer_read_sync+0xe3/0x110Read of size 8 at addr ffffc9000168f7f8 by task swapper/3/0CPU: 3 UID: 0 PID: 0 Comm: swapper/3 Not tainted 6.16.0-862.14.0.6.x86_64Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)Call Trace: <IRQ> dump_stack_lvl+0x55/0x70 print_address_description.constprop.0+0x2c/0x390 print_report+0xb4/0x270 kasan_report+0xb8/0xf0 end_buffer_read_sync+0xe3/0x110 end_bio_bh_io_sync+0x56/0x80 blk_update_request+0x30a/0x720 scsi_end_request+0x51/0x2b0 scsi_io_completion+0xe3/0x480 ? scsi_device_unbusy+0x11e/0x160 blk_complete_reqs+0x7b/0x90 handle_softirqs+0xef/0x370 irq_exit_rcu+0xa5/0xd0 sysvec_apic_timer_interrupt+0x6e/0x90 </IRQ> Above issue happens when do ntfs3 filesystem mount, issue may happens as follows:           mount                            IRQntfs_fill_super  read_cache_page    do_read_cache_folio      filemap_read_folio        mpage_read_folio\t do_mpage_readpage\t  ntfs_get_block_vbo\t   bh_read\t     submit_bh\t     wait_on_buffer(bh);\t                            blk_complete_reqs\t\t\t\t     scsi_io_completion\t\t\t\t      scsi_end_request\t\t\t\t       blk_update_request\t\t\t\t        end_bio_bh_io_sync\t\t\t\t\t end_buffer_read_sync\t\t\t\t\t  __end_buffer_read_notouch\t\t\t\t\t   unlock_buffer            wait_on_buffer(bh);--> return will return to caller\t\t\t\t\t  put_bh\t\t\t\t\t    --> trigger stack-out-of-boundsIn the mpage_read_folio() function, the stack variable 'map_bh' ispassed to ntfs_get_block_vbo(). Once unlock_buffer() unlocks andwait_on_buffer() returns to continue processing, the stack variableis likely to be reclaimed. Consequently, during the end_buffer_read_sync()process, calling put_bh() may result in stack overrun.If the bh is not allocated on the stack, it belongs to a folio.  Freeinga buffer head which belongs to a folio is done by drop_buffers() whichwill fail to free buffers which are still locked.  So it is safe to callput_bh() before __end_buffer_read_notouch().",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/w4zu/Debian_security"
        ]
    }
}