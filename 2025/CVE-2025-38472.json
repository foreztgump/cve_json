{
    "id": "CVE-2025-38472",
    "product": "Linux",
    "version": "",
    "vulnerability": [
        "n/a"
    ],
    "description": "In the Linux kernel, the following vulnerability has been resolved:netfilter: nf_conntrack: fix crash due to removal of uninitialised entryA crash in conntrack was reported while trying to unlink the conntrackentry from the hash bucket list:    [exception RIP: __nf_ct_delete_from_lists+172]    [..] #7 [ff539b5a2b043aa0] nf_ct_delete at ffffffffc124d421 [nf_conntrack] #8 [ff539b5a2b043ad0] nf_ct_gc_expired at ffffffffc124d999 [nf_conntrack] #9 [ff539b5a2b043ae0] __nf_conntrack_find_get at ffffffffc124efbc [nf_conntrack]    [..]The nf_conn struct is marked as allocated from slab but appears to be ina partially initialised state: ct hlist pointer is garbage; looks like the ct hash value (hence crash). ct->status is equal to IPS_CONFIRMED|IPS_DYING, which is expected ct->timeout is 30000 (=30s), which is unexpected.Everything else looks like normal udp conntrack entry.  If we ignorect->status and pretend its 0, the entry matches those that are newlyallocated but not yet inserted into the hash:  - ct hlist pointers are overloaded and store/cache the raw tuple hash  - ct->timeout matches the relative time expected for a new udp flow    rather than the absolute 'jiffies' value.If it were not for the presence of IPS_CONFIRMED,__nf_conntrack_find_get() would have skipped the entry.Theory is that we did hit following race:cpu x \t\t\tcpu y\t\t\tcpu z found entry E\t\tfound entry E E is expired\t\t<preemption> nf_ct_delete() return E to rcu slab\t\t\t\t\tinit_conntrack\t\t\t\t\tE is re-inited,\t\t\t\t\tct->status set to 0\t\t\t\t\treply tuplehash hnnode.pprev\t\t\t\t\tstores hash value.cpu y found E right before it was deleted on cpu x.E is now re-inited on cpu z.  cpu y was preempted beforechecking for expiry and/or confirm bit.\t\t\t\t\t->refcnt set to 1\t\t\t\t\tE now owned by skb\t\t\t\t\t->timeout set to 30000If cpu y were to resume now, it would observe E asexpired but would skip E due to missing CONFIRMED bit.\t\t\t\t\tnf_conntrack_confirm gets called\t\t\t\t\tsets: ct->status |= CONFIRMED\t\t\t\t\tThis is wrong: E is not yet added\t\t\t\t\tto hashtable.cpu y resumes, it observes E as expired but CONFIRMED:\t\t\t<resumes>\t\t\tnf_ct_expired()\t\t\t -> yes (ct->timeout is 30s)\t\t\tconfirmed bit set.cpu y will try to delete E from the hashtable:\t\t\tnf_ct_delete() -> set DYING bit\t\t\t__nf_ct_delete_from_listsEven this scenario doesn't guarantee a crash:cpu z still holds the table bucket lock(s) so y blocks:\t\t\twait for spinlock held by z\t\t\t\t\tCONFIRMED is set but there is no\t\t\t\t\tguarantee ct will be added to hash:\t\t\t\t\t\"chaintoolong\" or \"clash resolution\"\t\t\t\t\tlogic both skip the insert step.\t\t\t\t\treply hnnode.pprev still stores the\t\t\t\t\thash value.\t\t\t\t\tunlocks spinlock\t\t\t\t\treturn NF_DROP\t\t\t<unblocks, then\t\t\t crashes on hlist_nulls_del_rcu pprev>In case CPU z does insert the entry into the hashtable, cpu y will unlinkE again right away but no crash occurs.Without 'cpu y' race, 'garbage' hlist is of no consequence:ct refcnt remains at 1, eventually skb will be free'd and E getsdestroyed via: nf_conntrack_put -> nf_conntrack_destroy -> nf_ct_destroy.To resolve this, move the IPS_CONFIRMED assignment after the tableinsertion but before the unlock.Pablo points out that the confirm-bit-store could be reordered to happenbefore hlist add resp. the timeout fixup, so switch to set_bit andbefore_atomic memory barrier to prevent this.It doesn't matter if other CPUs can observe a newly inserted entry rightbefore the CONFIRMED bit was set:Such event cannot be distinguished from above \"E is the old incarnation\"case: the entry will be skipped.Also change nf_ct_should_gc() to first check the confirmed bit.The gc sequence is: 1. Check if entry has expired, if not skip to next entry 2. Obtain a reference to the expired entry. 3. Call nf_ct_should_gc() to double-check step 1.nf_ct_should_gc() is thus called only for entries that already failed anexpiry check. After this patch, once the confirmed bit check pas---truncated---",
    "poc": {
        "reference": [
            "No PoCs from references."
        ],
        "github": [
            "https://github.com/w4zu/Debian_security"
        ]
    }
}